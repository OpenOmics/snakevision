#!/usr/bin/env python3

# Python standard library
from __future__ import print_function
from abc import ABC, abstractmethod
import argparse, sys, os, textwrap

# 3rd party package from pypi,
# pip install if missing
import networkx as nx
import dagviz

# snakevision metadata
__version__  = '0.1.0'
__authors__  = 'Skyler Kuhn'
__home__     =  os.path.dirname(os.path.abspath(__file__))
_name        = os.path.basename(sys.argv[0]).replace('.py', '')
_description = 'create an awesome snakemake dag!'


class Colors():
    """Class encoding for ANSI escape sequeces for styling terminal text.
    Any string that is formatting with these styles must be terminated with
    the escape sequence, i.e. `Colors.end`.
    """
    # Escape sequence
    end = '\33[0m'
    # Formatting options
    bold   = '\33[1m'
    italic = '\33[3m'
    url    = '\33[4m'
    blink  = '\33[5m'
    higlighted = '\33[7m'
    # Text Colors
    black  = '\33[30m'
    red    = '\33[31m'
    green  = '\33[32m'
    yellow = '\33[33m'
    blue   = '\33[34m'
    pink  = '\33[35m'
    cyan  = '\33[96m'
    white = '\33[37m'
    # Background fill colors
    bg_black  = '\33[40m'
    bg_red    = '\33[41m'
    bg_green  = '\33[42m'
    bg_yellow = '\33[43m'
    bg_blue   = '\33[44m'
    bg_pink  = '\33[45m'
    bg_cyan  = '\33[46m'
    bg_white = '\33[47m'


def err(*message, **kwargs):
    """Prints any provided args to standard error.
    kwargs can be provided to modify print functions 
    behavior.
    @param message <any>:
        Values printed to standard error
    @params kwargs <print()>
        Key words to modify print function behavior
    """
    print(*message, file=sys.stderr, **kwargs)


def fatal(*message, **kwargs):
    """Prints any provided args to standard error
    and exits with an exit code of 1.
    @param message <any>:
        Values printed to standard error
    @params kwargs <print()>
        Key words to modify print function behavior
    """
    err(*message, **kwargs)
    sys.exit(1)


def parsed_arguments(name, description):
    """Parses user-provided command-line arguments. Requires argparse package. 
    argparse was added to standard lib in python 3.5.
    @param name <str>:
        Name of the command-line tool 
    @param description <str>:
        Short description of the command-line tool 
    @returns parsed cli args <object argparse.ArgumentParser.parse_args()>
    """

    # Add styled name and description
    _c = Colors
    _n = "{0}{1}{2}{3}{4}".format(_c.bold, _c.bg_black, _c.cyan, name, _c.end)
    _d = "{0}{1}{2}".format(_c.bold, description, _c.end)
    # Creating a cutsom help and usage message,
    # the default styling of argparse is too basic
    _styled_help = textwrap.dedent("""\
        {0}: {1}

        {3}{4}Synopsis:{5}
          $ {2} [--help] [--version] \\
                [--skip-rules RULE RULE ...] \\
                [--output OUTPUT] \\
                snakemake_rulegraph

        Optional arguments are shown in square brackets above.

        {3}{4}Description:{5}
          Create an awesome DAG from a snakemake rule graph. A rule graph 
        can be generated by running a pipeline with the `--forceall` and 
        `--rulegraph` options. The resulting rule graph can be saved to a
        file and provided as input, or the rule graph can be piped into 
        this program via standard input.

        {3}{4}Positional arguments:{5}
          snakemake_rulegraph
                Input snakemake rule graph to visualize. The rule graph
                can be provided as an  input file or it can be provided 
                via standard input (i.e. piped into the program).  If a 
                file is not provided as input,  it is assummed the rule
                graph should be read from standard input.  A snakemake 
                rule graph must be provided,  either as a file or via 
                standard input. 

        {3}{4}Options:{5}
          -o, --output OUTPUT
                Name of the output SVG file. The resulting DAG generated
                by the provided input snakemake rule graph will be saved
                to this file.
                    • Default: "snakevision_dag.svg"  
                    • Example: --output awesome_pipleine_dag.svg
        
          -s, --skip-rules RULE [RULE ...]
                Name of snakemake rule(s) to not include in the figure. 
                One or more rule names can be provided.  Any rule names 
                provided to  this option will not be included in the 
                final snakevision figure.
                    • Default: "all" "multiqc"  
                    • Example: --skip-rules All Multiqc FastQC

          -d, --debug-dag
                Increases verbosity to help debug any DAG errors.
                    • Example: --debug-dag  

          -h, --help
                Shows usage information, help message, and exits.
                    • Example: --help
    
          -v, --version
                Shows sematic version of tool and exits.
                    • Example: --version    
        """.format(_n, _d, name, _c.bold, _c.url, _c.end, _c.italic))

    # Supressing help messages, use style messages
    parser = argparse.ArgumentParser(
        usage = argparse.SUPPRESS,
        formatter_class = argparse.RawDescriptionHelpFormatter,
        description = _styled_help,
        add_help = False
    )
    # An optional positional argument that
    # takes a snakemake DAG as input:
    #     $ snakemake  --configfile=$outdir/config.json \
    #           -s $outdir/workflow/Snakefile \
    #           -d $outdir \
    #           --forceall \
    #           --rulegraph
    # If a file is not provided as input, then
    # the program will read from standard input.
    parser.add_argument(
        'input_file', 
        nargs='?', 
        type = argparse.FileType('r'), 
        default=sys.stdin,
        help = argparse.SUPPRESS
    )
    # Optional output file name for DAG figure,
    # defaults: default: "snakevision_dag.svg"
    parser.add_argument(
        '-o', '--output',
        type = lambda option: os.path.abspath(os.path.expanduser(option)),
        required = False,
        default = 'snakevision_dag.svg',
        help = argparse.SUPPRESS
    )

    # Define the name of rule all,
    # conventional name is 'all';
    # however a user can name it any-
    # thing. This rule in not included
    # in the final figure (recommended)
    # as it clutters image.
    parser.add_argument(
        '-s', '--skip-rules',
        type = str,
        required = False,
        nargs = '+',
        default = ['all', 'multiqc'],
        help = argparse.SUPPRESS
    )

    # Debugs DAG, increases verbosity
    parser.add_argument(
        '-d', '--debug-dag',
        action = 'store_true',
        default = False,
        required = False,
        help = argparse.SUPPRESS
    )
    
    # Add custom help message
    parser.add_argument(
        '-h', '--help',
        action = 'help',
        help = argparse.SUPPRESS
    )

    # Adding sematic verison information
    parser.add_argument(
        '-v', '--version',
        action = 'version',
        version='%(prog)s {}'.format(__version__),
        help = argparse.SUPPRESS
    )

    return parser.parse_args()


class AbstractSnakeVision(ABC):
    """An abstract base class for defining an common interface for snakevision. 
    A snakevision class contains methods for parsing rulegraphs, building a DAG, 
    and writing the resulting dag as a snakevision image.

    Usage example:
        dag = SnakeVision('snakemake_rulegraph')
        dag.write('/path/to/output/pipeline_dag.svg')
    """
    @abstractmethod
    def parse(self):
        ...
    
    @abstractmethod
    def build(self):
        ...
    
    @abstractmethod
    def write(self):
        ...  


class SnakeVision(AbstractSnakeVision):
    """SnakeVision class contains methods for parsing snakemake rule graphs, 
    building a DAG, and writing the resulting dag as a snakevision image.

    Usage example:
        dag = SnakeVision('snakemake_rulegraph')
        dag.write('/path/to/output/pipeline_dag.svg')
    """
    def __init__(self, input, dag = nx.DiGraph(), skip = [], verbose = False):
        self.input  = input         # Input open file handle to a snakemake rule graph
        self.dag    = dag           # networkx.DiGraph() object to model relationships 
        self.skip   = skip          # Do not add these rules in figure
        self.verbose     = verbose  # Prints parsed nodes and relationships
        self.node2label  = {}       # Maps node ids to rule names
        self.labels      = []       # Keeps track of rule name order
        self.n2n         = []       # Nested list keeps track of node-to-node relationships
        self.verbose_dag = ""       # Verbose dag debugging information 

        # Parse input snakemake rule graph.
        self.parse()
        # Builds dag from the parsed rule graph
        self.build()
        # Collect and display dag debugging information
        self.debug_dag()
        if self.verbose:
            print(self.verbose_dag)

    def __repr__(self):
        return textwrap.dedent(
            """
            Class usage example:
            dag = SnakeVision('snakemake_rulegraph.txt')
            dag.write('/path/to/output/pipeline_dag.svg')
            """
        )
    
    def __str__(self):
        return self.verbose_dag

    def debug_dag(self):
        """Displays verbose information of the parsed rule graph."""
        _c = Colors
        self.verbose_dag = textwrap.dedent(
            """
            {3}{4}Node-to-label mappings:{5}
            • {0}

            {3}{4}Node to node relationship:{5}
            • {1}

            {3}{4}Order of encountered labels:{5}
            • {2}
            """.format(
                self.node2label, 
                self.n2n, self.labels, 
                _c.bold, _c.url, _c.end
            )
        )

    def parse(self):
        """Parses a snakemake rule graph, saves parsed output in node2labels
        labels, and n2n instance variables. 
        
        Example input rule graph:
           0[label = "all", color = "0.34 0.6 0.85", style="rounded"];
           1[label = "fc_lane", color = "0.35 0.6 0.85", style="rounded"];
           2[label = "fastqc_raw", color = "0.09 0.6 0.85", style="rounded"];
           1 -> 0
           2 -> 0
        """
        for line in self.input:
            line = line.strip()
            # Skip over empty and un-important 
            # lines, rulegraph node ids start
            # with a number
            if not line: continue
            if not line[0].isdigit(): continue
            # Parse nodes and edges in dag,
            # need to map a node id to a 
            # snakemake rule name
            if '[' in line:
                # node definition line, i.e:
                # 0[label = "all", color = "0.34 0.6 0.85", style="rounded"];
                node = int(line.split('[')[0])
                label = line.split('=')[1].split(',')[0].strip().replace('"', '').replace("'", "")
                if label == self.skip:
                    # Get node ID of skip node, i.e
                    # rule all or the final target
                    skipnode = node
                self.node2label[node] = label
                self.labels.append(label)
            elif '->' in line:
                # node relationships or edges, i.e:
                # 1 -> 0
                nodes = [int(n.strip()) for n in line.split('->')]
                lab1 = self.node2label[nodes[0]]
                lab2 = self.node2label[nodes[1]]
                self.n2n.append([lab1, lab2])
    
    def build(self):
        """Builds a DAG from a parsed snakemake rule graph."""
        # Add nodes to the dag
        for lab in self.labels:
            if lab in self.skip:
                # Do NOT include rule all
                # in the final figure 
                continue
            self.dag.add_node(lab)
    
        # Add relationships or edges to dag
        for l1, l2 in self.n2n:
            if l1 in self.skip or l2 in self.skip:
                # Do NOT include rule all
                # in the final figure 
                continue
            self.dag.add_edge(l1, l2)

    def write(self, output = 'snakevision_dag.svg'):
        """Write DAG to output image."""
        # Create output directory as needed
        outdir = os.path.dirname(os.path.abspath(output))
        if not os.path.exists(outdir):
            # Pipeline output directory
            # does not exist on filesystem
            os.makedirs(outdir)
        # Write snakevision dag to SVG file
        o = dagviz.render_svg(self.dag)
        # Write SVG to a file
        with open(output, "wt") as fs:
            fs.write(o)


def main():
    # Parse command-line arguments
    args = parsed_arguments(name = _name, description = _description)

    # Create a snakevision dag object
    dag = SnakeVision(
        input = args.input_file,
        skip = args.skip_rules,
        verbose = args.debug_dag
    )

    # Write dag object to file
    dag.write(output = args.output)

if __name__ == '__main__':
    main()