#!/usr/bin/env python3

# Python standard library
from __future__ import print_function
import argparse, sys, os, textwrap

# 3rd party package from pypi,
# pip install if missing
import networkx as nx
import dagviz

# snakevision metadata
__version__  = '0.1.0'
__authors__  = 'Skyler Kuhn'
__home__     =  os.path.dirname(os.path.abspath(__file__))
_name        = os.path.basename(sys.argv[0]).replace('.py', '')
_description = 'create an awesome snakemake dag!'


class Colors():
    """Class encoding for ANSI escape sequeces for styling terminal text.
    Any string that is formatting with these styles must be terminated with
    the escape sequence, i.e. `Colors.end`.
    """
    # Escape sequence
    end = '\33[0m'
    # Formatting options
    bold   = '\33[1m'
    italic = '\33[3m'
    url    = '\33[4m'
    blink  = '\33[5m'
    higlighted = '\33[7m'
    # Text Colors
    black  = '\33[30m'
    red    = '\33[31m'
    green  = '\33[32m'
    yellow = '\33[33m'
    blue   = '\33[34m'
    pink  = '\33[35m'
    cyan  = '\33[96m'
    white = '\33[37m'
    # Background fill colors
    bg_black  = '\33[40m'
    bg_red    = '\33[41m'
    bg_green  = '\33[42m'
    bg_yellow = '\33[43m'
    bg_blue   = '\33[44m'
    bg_pink  = '\33[45m'
    bg_cyan  = '\33[46m'
    bg_white = '\33[47m'


def err(*message, **kwargs):
    """Prints any provided args to standard error.
    kwargs can be provided to modify print functions 
    behavior.
    @param message <any>:
        Values printed to standard error
    @params kwargs <print()>
        Key words to modify print function behavior
    """
    print(*message, file=sys.stderr, **kwargs)


def fatal(*message, **kwargs):
    """Prints any provided args to standard error
    and exits with an exit code of 1.
    @param message <any>:
        Values printed to standard error
    @params kwargs <print()>
        Key words to modify print function behavior
    """
    err(*message, **kwargs)
    sys.exit(1)


def parsed_arguments(name, description):
    """Parses user-provided command-line arguments. Requires argparse package. 
    argparse was added to standard lib in python 3.5.
    @param name <str>:
        Name of the command-line tool 
    @param description <str>:
        Short description of the command-line tool 
    @returns parsed cli args <object argparse.ArgumentParser.parse_args()>
    """

    # Add styled name and description
    _c = Colors
    _n = "{0}{1}{2}{3}{4}".format(_c.bold, _c.bg_black, _c.cyan, name, _c.end)
    _d = "{0}{1}{2}".format(_c.bold, description, _c.end)
    # Creating a cutsom help and usage message,
    # the default styling of argparse is too basic
    _styled_help = textwrap.dedent("""\
        {0}: {1}

        {3}{4}Synopsis:{5}
          $ {2} [--help] [--version] \\
                [--skip-rules RULE RULE ...] \\
                [--output OUTPUT] \\
                snakemake_rulegraph

        Optional arguments are shown in square brackets above.

        {3}{4}Description:{5}
          Create an awesome DAG from a snakemake rule graph. A rule graph 
        can be generated by running a pipeline with the `--forceall` and 
        `--rulegraph` options. The resulting rule graph can be saved to a
        file and provided as input, or the rule graph can be piped into 
        this program via standard input.

        {3}{4}Positional arguments:{5}
          snakemake_rulegraph
                Input snakemake rule graph to visualize. The rule graph
                can be provided as an  input file or it can be provided 
                via standard input (i.e. piped into the program).  If a 
                file is not provided as input,  it is assummed the rule
                graph should be read from standard input.  A snakemake 
                rule graph must be provided,  either as a file or via 
                standard input. 

        {3}{4}Options:{5}
          -o, --output OUTPUT
                Name of the output SVG file. The resulting DAG generated
                by the provided input snakemake rule graph will be saved
                to this file.
                    • Default: "snakevision_dag.svg"  
                    • Example: --output awesome_pipleine_dag.svg
        
          -s, --skip-rules RULE [RULE ...]
                Name of snakemake rule(s) to not include in the figure. 
                One or more rule names can be provided.  Any rule names 
                provided to  this option will not be included in the 
                final snakevision figure.
                    • Default: "all" "multiqc"  
                    • Example: --skip-rules All Multiqc FastQC

          -h, --help
                Shows usage information, help message, and exits.
                    • Example: --help
    
          -v, --version
                Shows sematic version of tool and exits.
                    • Example: --version    
        """.format(_n, _d, name, _c.bold, _c.url, _c.end, _c.italic))

    # Supressing help messages, use style messages
    parser = argparse.ArgumentParser(
        usage = argparse.SUPPRESS,
        formatter_class = argparse.RawDescriptionHelpFormatter,
        description = _styled_help,
        add_help = False
    )
    # An optional positional argument that
    # takes a snakemake DAG as input:
    #     $ snakemake  --configfile=$outdir/config.json \
    #           -s $outdir/workflow/Snakefile \
    #           -d $outdir \
    #           --forceall \
    #           --rulegraph
    # If a file is not provided as input, then
    # the program will read from standard input.
    parser.add_argument(
        'input_file', 
        nargs='?', 
        type = argparse.FileType('r'), 
        default=sys.stdin,
        help = argparse.SUPPRESS
    )
    # Optional output file name for DAG figure,
    # defaults: default: "snakevision_dag.svg"
    parser.add_argument(
        '-o', '--output',
        type = lambda option: os.path.abspath(os.path.expanduser(option)),
        required = False,
        default = 'snakevision_dag.svg',
        help = argparse.SUPPRESS
    )

    # Define the name of rule all,
    # conventional name is 'all';
    # however a user can name it any-
    # thing. This rule in not included
    # in the final figure (recommended)
    # as it clutters image.
    parser.add_argument(
        '-s', '--skip-rules',
        type = str,
        required = False,
        nargs = '+',
        default = ['all', 'multiqc'],
        help = argparse.SUPPRESS
    )
    
    # Add custom help message
    parser.add_argument(
        '-h', '--help',
        action = 'help',
        help = argparse.SUPPRESS
    )

    # Adding sematic verison information
    parser.add_argument(
        '-v', '--version',
        action = 'version',
        version='%(prog)s {}'.format(__version__),
        help = argparse.SUPPRESS
    )

    return parser.parse_args()


def snakevision(dag, output, skip = None):
    """Creates a snakevision figure from a snakemake DAG.
    Convert this to a class, add methods for parsing,
    instantiating, and writing the DAG to an SVG.
    """
    node2label = {}
    labels = []
    n2n = []
    # Parse snakemake dag
    # TODO: convert to method
    for line in dag:
        line = line.strip()
        if not line:
            # skip over empty lines
            continue
        if not line[0].isdigit():
            continue
        # nodes and edges in dag
        # parse these to map node
        # id to snakemake rule
        # 0[label = "all", color = "0.34 0.6 0.85", style="rounded"];
        # 1[label = "fc_lane", color = "0.35 0.6 0.85", style="rounded"];
        # 2[label = "fastqc_raw", color = "0.09 0.6 0.85", style="rounded"];
        # 1 -> 0
        # 2 -> 0
        if '[' in line:
            # node definition line, i.e:
            # 0[label = "all", color = "0.34 0.6 0.85", style="rounded"];
            node = int(line.split('[')[0])
            label = line.split('=')[1].split(',')[0].strip().replace('"', '').replace("'", "")
            if label == skip:
                # Get node ID of skip node, i.e
                # rule all or the final target
                skipnode = node
            node2label[node] = label
            labels.append(label)

        elif '->' in line:
            # node relationships or edges, i.e:
            # 1 -> 0
            nodes = [int(n.strip()) for n in line.split('->')]
            lab1 = node2label[nodes[0]]
            lab2 = node2label[nodes[1]]
            n2n.append([lab1, lab2])
    
    # Instantiate the dag, add nodes
    # TODO: convert to method
    G = nx.DiGraph()
    for lab in labels:
        if lab in skip:
            # Do NOT include rule all
            # in the final figure 
            continue
        G.add_node(lab)
        print(lab)

    # Add relationships or edges to dag
    for l1, l2 in n2n:
        if l1 in skip or l2 in skip:
            # Do NOT include rule all
            # in the final figure 
            continue
        G.add_edge(l1, l2)
        print(l1, "->", l2)
    
    # Write snakevision dag to SVG file
    # TODO: convert to method
    r = dagviz.render_svg(G)
    # Write SVG to a file
    with open(output, "wt") as fs:
        fs.write(r)


def main():
    # Parse command-line arguments
    args = parsed_arguments(name = _name, description = _description)
    
    # Create output directory as needed
    outdir = os.path.dirname(os.path.abspath(args.output))
    if not os.path.exists(outdir):
        # Pipeline output directory
        # does not exist on filesystem
        os.makedirs(outdir)

    # Create a snaekviz DAG
    snakevision(
        dag = args.input_file,
        output = args.output,
        skip = args.skip_rules
    )


if __name__ == '__main__':
    main()